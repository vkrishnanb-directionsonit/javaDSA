# Content List

### 1. Introduction
	 1.01	Variables  
	 1.02	Data Types  
	 1.03	Data Structure  
	 1.04	Abstract Data Types	(ADTs)  
	 1.05	What is	an Algorithm?  
	 1.06	Why	the	Analysis of	Algorithms?  
	 1.07	Goal	of	the	Analysis	of	Algorithms  
	 1.08	What	is	Running	Time	Analysis?  
	 1.09	How	to	Compare	Algorithms  
	 1.10	What	is	Rate	of	Growth?  
	 1.11	Commonly	used	Rates	of	Growth  
	 1.12	Types	of	Analysis  
	 1.13	Asymptotic	Notation  
	 1.14	Big-O	Notation  
	 1.15	Omega-Ω	Notation  
	 1.16	Theta-Θ	Notation  
	 1.17	Important	Notes  
	 1.18	Why	is	it	called	Asymptotic	Analysis?  
	 1.19	Guidelines	for	Asymptotic	Analysis  
	 1.20	Properties	of	Notations  
	 1.21	Commonly used Logarithms	and	Summations  
	 1.22	Master	Theorem	for	Divide	and	Conquer  
	 1.23	Divide	and	Conquer	Master	Theorem:	Problems	&	Solutions  
	 1.24	Master	Theorem	for	Subtract	and	Conquer	Recurrences  
	 1.25	Variant	of	Subtraction	and	Conquer	Master	Theorem  
	 1.26	Method	of	Guessing and Confirming  
	 1.27	Amortized	Analysis  
	 1.28	Algorithms	Analysis:	Problems	&	Solutions  
### 2.	Recursion	and	Backtracking
 2.1 Introduction
 2.2 What	is	Recursion?
 2.3 Why	Recursion?
 2.4 Format	of	a	Recursive	Function
 2.5 Recursion	and	Memory	(Visualization)
 2.6 Recursion	versus	Iteration
 2.7 Notes	on	Recursion
 2.8 Example	Algorithms	of	Recursion
 2.9 Recursion:	Problems	&	Solutions
 2.10		What	is	Backtracking?
 2.11		Example	Algorithms	of	Backtracking
 2.12		Backtracking:	Problems	&	Solutions
### 3.			Linked	Lists
 3.1 What	is	a	Linked	List?
 3.2 Linked	Lists	ADT
 3.3 Why	Linked	Lists?
 3.4 Arrays	Overview
 3.5 Comparison	of	Linked	Lists	with	Arrays	&	Dynamic	Arrays
 3.6 Singly	Linked	Lists
 3.7 Doubly	Linked	Lists
 3.8 Circular	Linked	Lists
 3.9 A	Memory-efficient	Doubly	Linked	List
 3.10		Unrolled	Linked	Lists
 3.11		Skip	Lists
 3.12		Linked	Lists:	Problems	&	Solutions
### 4.			Stacks
 4.1 What	is	a	Stack?
 4.2 How	Stacks	are	used
 4.3 Stack	ADT
 4.4 Exceptions
 4.5 Applications
 4.6 Implementation
 4.7 Comparison	of	Implementations
 4.8 Stacks:	Problems	&	Solutions
### 5.			Queues
 5.1 What	is	a	Queue?
 5.2 How	are	Queues	Used
 5.3 Queue	ADT
 5.4 Exceptions
 5.5 Applications
 5.6 Implementation
 5.7 Queues:	Problems	&	Solutions
### 6.			Trees
 6.1 What	is	a	Tree?
 6.2 Glossary
 6.3 Binary	Trees
 6.4 Binary	Tree	Traversals
 6.5 Generic	Trees	(N-ary	Trees)
 6.6 Threaded	Binary	Tree	Traversals	(Stack	or	Queue-less	Traversals)
 6.7 Expression	Trees
 6.8 XOR	Trees
 6.9 Binary	Search	Trees	(BSTs)
 6.10		Balanced	Binary	Search	Trees
 6.11		AVL	(Adelson-Velskii	and	Landis)	Trees
 6.12		Other	Variations	on	Trees
### 7.			Priority	Queues	and	Heaps
 7.1 What	is	a	Priority	Queue?
 7.2 Priority	Queue	ADT
 7.3 Priority	Queue	Applications
 7.4 Priority	Queue	Implementations
 7.5 Heaps	and	Binary	Heaps
 7.6 Binary	Heaps
 7.7 Priority	Queues	[Heaps]:	Problems	&	Solutions
### 8.			Disjoint	Sets	ADT
 8.1 Introduction
 8.2 Equivalence	Relations	and	Equivalence	Classes
 8.3 Disjoint	Sets	ADT
 8.4 Applications
 8.5 Tradeoffs	in	Implementing	Disjoint	Sets	ADT
 8.6 Fast	UNION	Implementation	(Slow	FIND)
 8.7 Fast	UNION	Implementations	(Quick	FIND)
 8.8 Path	Compression
 8.9 Summary
 8.10		Disjoint	Sets:	Problems	&	Solutions
### 9.			Graph	Algorithms
 9.1 Introduction
 9.2 Glossary
 9.3 Applications	of	Graphs
 9.4 Graph	Representation
 9.5 Graph	Traversals
 9.6 Topological	Sort
 9.7 Shortest	Path	Algorithms
 9.8 Minimal	Spanning	Tree
 9.9 Graph	Algorithms:	Problems	&	Solutions
### 10.	Sorting
 10.1 What	is	Sorting?
 10.2 Why	is	Sorting	Necessary?
 10.3 Classification	of	Sorting	Algorithms
 10.4 Other	Classifications
 10.5 Bubble	Sort
 10.6 Selection	Sort
 10.7 Insertion	Sort
 10.8 Shell	Sort
 10.9 Merge	Sort
 10.10 Heap	Sort
 10.11 Quick	Sort
 10.12 Tree	Sort
 10.13 Comparison	of	Sorting	Algorithms
 10.14 Linear	Sorting	Algorithms
 10.15 Counting	Sort
 10.16 Bucket	Sort	(or	Bin	Sort)
 10.17 Radix	Sort
 10.18 Topological	Sort
 10.19 External	Sorting
 10.20 Sorting:	Problems	&	Solutions
### 11.	Searching
 11.1 What	is	Searching?
 11.2 Why	do	we	need	Searching?
 11.3 Types	of	Searching
 11.4 Unordered	Linear	Search
 11.5 Sorted/Ordered	Linear	Search
 11.6 Binary	Search
 11.7 Interpolation	Search
 11.8 Comparing	Basic	Searching	Algorithms
 11.9 Symbol	Tables	and	Hashing
 11.10 String	Searching	Algorithms
 11.11 Searching:	Problems	&	Solutions
### 12.	Selection	Algorithms	[Medians]
 12.1 What	are	Selection	Algorithms?
 12.2 Selection	by	Sorting
 12.3 Partition-based	Selection	Algorithm
 12.4 Linear	Selection	Algorithm	-	Median	of	Medians	Algorithm
 12.5 Finding	the	K	Smallest	Elements	in	Sorted	Order
 12.6 Selection	Algorithms:	Problems	&	Solutions
### 13.	Symbol	Tables
 13.1 Introduction
 13.2 What	are	Symbol	Tables?
 13.3 Symbol	Table	Implementations
 13.4 Comparison	Table	of	Symbols	for	Implementations
### 14.	Hashing
 14.1 What	is	Hashing?
 14.2 Why	Hashing?
 14.3 HashTable	ADT
 14.4 Understanding	Hashing
 14.5 Components	of	Hashing
 14.6 Hash	Table
 14.7 Hash	Function
 14.8 Load	Factor
 14.9 Collisions
 14.10 Collision	Resolution	Techniques
 14.11 Separate	Chaining
 14.12 Open	Addressing
 14.13 Comparison	of	Collision	Resolution	Techniques
 14.14 How	Hashing	Gets	O(1)	Complexity?
 14.15 Hashing	Techniques
 14.16 Problems	for	which	Hash	Tables	are	not	suitable
 14.17 Bloom	Filters
 14.18 Hashing:	Problems	&	Solutions
### 15.	String	Algorithms
 15.1 Introduction
 15.2 String	Matching	Algorithms
 15.3 Brute	Force	Method
 15.4 Rabin-Karp	String	Matching	Algorithm
 15.5 String	Matching	with	Finite	Automata
 15.6 KMP	Algorithm
 15.7 Boyer-Moore	Algorithm
 15.8 Data	Structures	for	Storing	Strings
 15.9 Hash	Tables	for	Strings
 15.10 Binary	Search	Trees	for	Strings
 15.11 Tries
 15.12 Ternary	Search	Trees
 15.13 Comparing	BSTs,	Tries	and	TSTs
 15.14 Suffix	Trees
 15.15 String	Algorithms:	Problems	&	Solutions
### 16.	Algorithms	Design	Techniques
 16.1 Introduction
 16.2 Classification
 16.3 Classification	by	Implementation	Method
 16.4 Classification	by	Design	Method
 16.5 Other	Classifications
### 17.	Greedy	Algorithms
 17.1 Introduction
 17.2 Greedy	Strategy
 17.3 Elements	of	Greedy	Algorithms
 17.4 Does	Greedy	Always	Work?
 17.5 Advantages	and	Disadvantages	of	Greedy	Method
 17.6 Greedy	Applications
 17.7 Understanding	Greedy	Technique
 17.8 Greedy	Algorithms:	Problems	&	Solutions
### 18.	Divide	and	Conquer	Algorithms
 18.1 Introduction
 18.2 What	is	Divide	and	Conquer	Strategy?
 18.3 Does	Divide	and	Conquer	Always	Work?
 18.4 Divide	and	Conquer	Visualization
 18.5 Understanding	Divide	and	Conquer
 18.6 Advantages	of	Divide	and	Conquer
 18.7 Disadvantages	of	Divide	and	Conquer
 18.8 Master	Theorem
 18.9 Divide	and	Conquer	Applications
 18.10 Divide	and	Conquer:	Problems	&	Solutions
### 19.	Dynamic	Programming
 19.1 Introduction
 19.2 What	is	Dynamic	Programming	Strategy?
 19.3 Properties	of	Dynamic	Programming	Strategy
 19.4 Can	Dynamic	Programming	Solve	All	Problems?
 19.5 Dynamic	Programming	Approaches
 19.6 Examples	of	Dynamic	Programming	Algorithms
 19.7 Understanding	Dynamic	Programming
 19.8 Dynamic	Programming:	Problems	&	Solutions
### 20.	Complexity	Classes
 20.1 Introduction
 20.2 Polynomial/Exponential	Time
 20.3 What	is	a	Decision	Problem?
 20.4 Decision	Procedure
 20.5 What	is	a	Complexity	Class?
 20.6 Types	of	Complexity	Classes
 20.7 Reductions
 20.8 Complexity	Classes:	Problems	&	Solutions
### 21.	Miscellaneous	Concepts
 21.1 Introduction
 21.2 Hacks	on	Bitwise	Programming
 21.3 Other	Programming	Question